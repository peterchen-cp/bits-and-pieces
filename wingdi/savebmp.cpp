#include "../pch.h"
#include "savebmp.h"
#include "../core/finally.h"

/* adapted from https://docs.microsoft.com/de-de/windows/win32/gdi/storing-an-image?redirectedfrom=MSDN:
   "Docs / Windows / Windows GDI / Bitmaps / Using Bitmaps / Storing an Image "

   I've tried to preserve the structure, with the following modifications:

    - using \ref Finally for resource management (changing errors to exceptions would be a-OK)
    - error handling is "Win32 style": returning null/false on error, with the error code in GetLastError()
    - removed the HWND since it's used only for error handling
    - using malloc for allocation (it's "well-aligned for everything" and "not as deprecated as" Global/LocalAlloc)

   I also have a case where it doesn't work as expected:

      - Load a 16-color image ("classic" toolbar image resource generated by MFC wizard) through ImageList_LoadImage
      - Use ImageList_GetImageInfo to retrieve the FBITMAP's for the image 
      - save this through this function
      - Result: the resulting file has an all-zero palette
*/

namespace GDIUtil
{

   namespace
   {
      PBITMAPINFO CreateBitmapInfoStruct(HBITMAP hBmp)
      {
         BITMAP bmp = {};
         PBITMAPINFO pbmi = nullptr;
         WORD    cClrBits = 0;

         // Retrieve the bitmap color format, width, and height.  
         if (!GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bmp))
            return nullptr;

         // Convert the color format to a count of bits.  
         cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel);
         if (cClrBits == 1)
            cClrBits = 1;
         else if (cClrBits <= 4)
            cClrBits = 4;
         else if (cClrBits <= 8)
            cClrBits = 8;
         else if (cClrBits <= 16)
            cClrBits = 16;
         else if (cClrBits <= 24)
            cClrBits = 24;
         else cClrBits = 32;

         // Allocate memory for the BITMAPINFO structure. (This structure  
         // contains a BITMAPINFOHEADER structure and an array of RGBQUAD  
         // data structures.)  
         // There is no RGBQUAD array for these formats: 24-bit-per-pixel or 32-bit-per-pixel 
         size_t bmiSize = sizeof(BITMAPINFOHEADER);
         if (cClrBits < 24)
            bmiSize += sizeof(RGBQUAD) * (1 << cClrBits);

         pbmi = (PBITMAPINFO)malloc(bmiSize);
         if (!pbmi)
         {
            SetLastError(ERROR_OUTOFMEMORY);
            return nullptr;
         }
         memset(pbmi, 0, bmiSize);
         // pbmi is return value, shall be freed by caller

         // Initialize the fields in the BITMAPINFO structure.  
         pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
         pbmi->bmiHeader.biWidth = bmp.bmWidth;
         pbmi->bmiHeader.biHeight = bmp.bmHeight;
         pbmi->bmiHeader.biPlanes = bmp.bmPlanes;
         pbmi->bmiHeader.biBitCount = bmp.bmBitsPixel;
         if (cClrBits < 24)
            pbmi->bmiHeader.biClrUsed = (1 << cClrBits);

         // If the bitmap is not compressed, set the BI_RGB flag.  
         pbmi->bmiHeader.biCompression = BI_RGB;

         // Compute the number of bytes in the array of color  
         // indices and store the result in biSizeImage.  
         // The width must be DWORD aligned unless the bitmap is RLE 
         // compressed. 
         pbmi->bmiHeader.biSizeImage = ((pbmi->bmiHeader.biWidth * cClrBits + 31) & ~31) / 8
            * pbmi->bmiHeader.biHeight;
         // Set biClrImportant to 0, indicating that all of the  
         // device colors are important.  
         pbmi->bmiHeader.biClrImportant = 0;
         return pbmi;
      }


   } // namespace



   bool BitmapSaveToFile(LPCTSTR pszFile, PBITMAPINFO pbi,
      HBITMAP hBMP, HDC hDC)
   {
      HANDLE hf = nullptr;                // output file handle  
      BITMAPFILEHEADER hdr = {};          // bitmap file-header  
      PBITMAPINFOHEADER pbih = nullptr;   // bitmap info-header  
      LPBYTE lpBits = nullptr;            // memory pointer  (color table and pixels)
      DWORD dwTotal = 0;                  // total count of bytes  
      DWORD cb = 0;                       // incremental count of bytes  
      BYTE *hp = nullptr;                 // byte pointer  
      DWORD dwTmp = 0;

      pbih = (PBITMAPINFOHEADER)pbi;
      lpBits = (LPBYTE) malloc(pbih->biSizeImage);
      if (!lpBits)
      {
         SetLastError(ERROR_OUTOFMEMORY);
         return false;
      }
      Finally gmem = [&] { free(lpBits); };

      // Retrieve the color table (RGBQUAD array) and the bits  
      // (array of palette indices) from the DIB.  
      if (!GetDIBits(hDC, hBMP, 0, (WORD)pbih->biHeight, lpBits, pbi, DIB_RGB_COLORS))
         return false;

      // Create the .BMP file.  
      hf = CreateFile(pszFile,
         GENERIC_READ | GENERIC_WRITE,
         (DWORD)0,
         NULL,
         CREATE_ALWAYS,
         FILE_ATTRIBUTE_NORMAL,
         (HANDLE)NULL);
      if (hf == INVALID_HANDLE_VALUE)
         return false;

      hdr.bfType = 0x4d42;        // 0x42 = "B" 0x4d = "M"  
      // Compute the size of the entire file.  
      hdr.bfSize = (DWORD)(sizeof(BITMAPFILEHEADER) +
         pbih->biSize + pbih->biClrUsed
         * sizeof(RGBQUAD) + pbih->biSizeImage);
      hdr.bfReserved1 = 0;
      hdr.bfReserved2 = 0;

      // Compute the offset to the array of color indices.  
      hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) +
         pbih->biSize + pbih->biClrUsed
         * sizeof(RGBQUAD);

      // Copy the BITMAPFILEHEADER into the .BMP file.  
      if (!WriteFile(hf, (LPVOID)&hdr, sizeof(BITMAPFILEHEADER),
         (LPDWORD)&dwTmp, NULL))
         return false;

      // Copy the BITMAPINFOHEADER and RGBQUAD array into the file.  
      if (!WriteFile(hf, (LPVOID)pbih, sizeof(BITMAPINFOHEADER)
         + pbih->biClrUsed * sizeof(RGBQUAD),
         (LPDWORD)&dwTmp, (NULL)))
         return false;

      // Copy the array of color indices into the .BMP file.  
      dwTotal = cb = pbih->biSizeImage;
      hp = lpBits;
      if (!WriteFile(hf, (LPSTR)hp, (int)cb, (LPDWORD)&dwTmp, NULL))
         return false;

      // Close the .BMP file.  
      if (!CloseHandle(hf))
         return false;

      return true;
   }

   // added by me, guesswork:
   bool BitmapSaveToFile(LPCTSTR pszFile, HBITMAP hBMP)
   {
      HDC dc = CreateCompatibleDC(nullptr);
      Finally gdc = [&] { DeleteDC(dc); };

      PBITMAPINFO pbmi = CreateBitmapInfoStruct(hBMP);
      Finally gbmi = [&] { free(pbmi); };

      auto prev = SelectObject(dc, hBMP);
      Finally gbmp = [&] {SelectObject(dc, prev); };

      return BitmapSaveToFile(pszFile, pbmi, hBMP, dc);
   }


}
